extern crate clap;
extern crate rand;
extern crate sharedlib;
extern crate tarpc;
extern crate tarpc_bincode_transport;
extern crate tokio;
use crate::tarpc::futures::compat::Executor01CompatExt;
use crate::tarpc::futures::FutureExt;
use crate::tarpc::futures::TryFutureExt;

use clap::{App, Arg};
use futures::{
    future::{self, Ready},
    prelude::*,
};
use service::Service;
use std::{io, net::IpAddr};
use tarpc::{
    context,
    server::{self, Channel, Handler},
};
use tokio_serde::formats::Json;

#[derive(Clone)]
struct Server;

impl Service for Server {
    type WriteFut = Ready<String>;
    fn write(self, _: tarpc::context::Context, value: String) -> Self::WriteFut {
        futures::future::ready(format!("Writing {}", value))
    }
}

async fn main() -> io::Result<()> {
    let flags = App::new("Write Server")
        .version("0.1")
        .author("Pi Songkuntham")
        .arg(Arg::with_name("port").required(true).takes_value(true))
        .get_matches();
    let port = flags.value_of("port").unwrap();
    let server_addr = (IpAddr::from([0, 0, 0, 0]), port);
    let server_transport = bincode_transport::listen(&server_addr)?;

    // The server is configured with the defaults.
    let server = server::new(server::Config::default())
        // Server can listen on any type that implements the Transport trait.
        .incoming(server_transport)
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .respond_with(Server.serve());

    tokio::spawn(server);

    Ok(())
}
